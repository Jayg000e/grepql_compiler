let string_of_op = function
let string_of_uop = function
let rec string_of_expr = function
    Literal(l) -> string_of_int l
      string_of_expr e1 ^ " " ^ string_of_op o ^ " " ^ string_of_expr e2
  | Unop(o, e) -> string_of_uop o ^ string_of_expr e
  | Assign(v, e) -> v ^ " = " ^ string_of_expr e
      f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
    "SELECT * FROM " ^ string_of_expr e ^ (match cond_opt with 
                                            | Some(cond) -> " WHERE " ^ string_of_condition cond)
    "GREP " ^ string_of_expr e1 ^ " FROM " ^ string_of_expr e2
    "SAVE " ^ string_of_expr e1 ^ " TO " ^ string_of_expr e2
    "LOAD " ^ string_of_expr e 
  | Count(e) -> "COUNT " ^ string_of_expr e 
  | Check(e) -> "CHECK " ^ string_of_expr e
  | Append(e1, e2) -> string_of_expr e1 ^ "->" ^ string_of_expr e2
and string_of_condition = function
| FileSizeCondition(op, e) -> "SIZE " ^ string_of_comparison_op op ^ " " ^ string_of_expr e
| DateCondition(op, e) -> "DATE " ^ string_of_comparison_op op ^ " " ^ string_of_expr e
| RegxCondition(e) -> "LIKE " ^ string_of_expr e
and string_of_comparison_op = function
let rec string_of_stmt = function
      "{\n" ^ String.concat "" (List.map string_of_stmt stmts) ^ "}\n"
  | Expr(expr) -> string_of_expr expr ^ ";\n";
  | Return(expr) -> "return " ^ string_of_expr expr ^ ";\n";
  | If(e, s, Block([])) -> "if (" ^ string_of_expr e ^ ")\n" ^ string_of_stmt s
  | If(e, s1, s2) ->  "if (" ^ string_of_expr e ^ ")\n" ^
      string_of_stmt s1 ^ "else\n" ^ string_of_stmt s2
      "for (" ^ string_of_expr e1  ^ " ; " ^ string_of_expr e2 ^ " ; " ^
      string_of_expr e3  ^ ") " ^ string_of_stmt s
  | While(e, s) -> "while (" ^ string_of_expr e ^ ") " ^ string_of_stmt s
let string_of_typ = function
let string_of_vdecl (t, id) = string_of_typ t ^ " " ^ id ^ ";\n"
let string_of_fdecl fdecl =
  string_of_typ fdecl.typ ^ " " ^
  String.concat "" (List.map string_of_vdecl fdecl.locals) ^
  String.concat "" (List.map string_of_stmt fdecl.body) ^
let string_of_program (vars, funcs) =
  String.concat "" (List.map string_of_vdecl vars) ^ "\n" ^
  String.concat "\n" (List.map string_of_fdecl funcs)
  print_endline (string_of_sprogram sprogram)
ernalFormat__string_of_fmtty_3218
  print_endline (string_of_program program)
      formals = List.mapi (fun i ty -> (ty, "x" ^ string_of_int i)) param_types;
          let err = "illegal assignment " ^ string_of_typ lt ^ " = " ^ 
            string_of_typ rt ^ " in " ^ string_of_expr ex
                                 string_of_uop op ^ string_of_typ t ^
                                 " in " ^ string_of_expr ex))
                       string_of_typ t1 ^ " " ^ string_of_op op ^ " " ^
                       string_of_typ t2 ^ " in " ^ string_of_expr e))
            raise (Failure ("expecting " ^ string_of_int param_length ^ 
                            " arguments in " ^ string_of_expr call))
            let err = "illegal argument found " ^ string_of_typ et ^
              " expected " ^ string_of_typ ft ^ " in " ^ string_of_expr e
      and err = "expected Int expression in " ^ string_of_expr e
      and err = "expected Strings expression in " ^ string_of_expr e
      and err = "expected String expression in " ^ string_of_expr e
      and err = "expected Boolean expression in " ^ string_of_expr e
	  Failure ("return gives " ^ string_of_typ t ^ " expected " ^
		   string_of_typ func.typ ^ " in " ^ string_of_expr e)) *)
@tmp.4 = private unnamed_addr constant [10 x i8] c"string_of\00", align 1
    (* Ast -> print_string (Ast.string_of_program ast) *)
    | Sast    -> print_string (Sast.string_of_sprogram sast)
    | LLVM_IR -> print_string (Llvm.string_of_llmodule (Codegen.translate sast))
	print_string (Llvm.string_of_llmodule m)
  SAVE GREP "string_of" FROM "." TO "result.txt";
let rec string_of_sexpr (t, e) =
  "(" ^ string_of_typ t ^ " : " ^ (match e with
    SLiteral(l) -> string_of_int l
      string_of_sexpr e1 ^ " " ^ string_of_op o ^ " " ^ string_of_sexpr e2
  | SUnop(o, e) -> string_of_uop o ^ string_of_sexpr e
  | SAssign(v, e) -> v ^ " = " ^ string_of_sexpr e
      f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
  | SCount(e) -> "COUNT " ^ string_of_sexpr e 
  | SSave(e1, e2) -> "SAVE " ^ string_of_sexpr e1 ^ " TO " ^ string_of_sexpr e2 
  | SLoad(e) -> "LOAD " ^ string_of_sexpr e
  | SAppend(e1, e2) -> string_of_sexpr e1 ^ "->" ^ string_of_sexpr e2
  | SCheck(e) -> "CHECK " ^ string_of_sexpr e 
    "GREP " ^ string_of_sexpr e1 ^ " FROM " ^ string_of_sexpr e2
  | SQuery(e, None) -> "SELECT * FROM " ^ string_of_sexpr e
      "SELECT * FROM " ^ string_of_sexpr e ^ " WHERE " ^ string_of_scondition cond ^ ")"
and string_of_scondition = function
  | SFileSizeCondition(op, e) -> "SIZE " ^ string_of_comparison_op op ^ " " ^ string_of_sexpr e
  | SDateCondition(op, e) -> "DATE " ^ string_of_comparison_op op ^ " " ^ string_of_sexpr e
  | SRegxCondition(e) -> "LIKE " ^ string_of_sexpr e
let rec string_of_sstmt = function
      "{\n" ^ String.concat "" (List.map string_of_sstmt stmts) ^ "}\n"
  | SExpr(expr) -> string_of_sexpr expr ^ ";\n";
  | SReturn(expr) -> "return " ^ string_of_sexpr expr ^ ";\n";
      "if (" ^ string_of_sexpr e ^ ")\n" ^ string_of_sstmt s
  | SIf(e, s1, s2) ->  "if (" ^ string_of_sexpr e ^ ")\n" ^
      string_of_sstmt s1 ^ "else\n" ^ string_of_sstmt s2
      "for (" ^ string_of_sexpr e1  ^ " ; " ^ string_of_sexpr e2 ^ " ; " ^
      string_of_sexpr e3  ^ ") " ^ string_of_sstmt s
  | SWhile(e, s) -> "while (" ^ string_of_sexpr e ^ ") " ^ string_of_sstmt s
let string_of_sfdecl fdecl =
  string_of_typ fdecl.styp ^ " " ^
  String.concat "" (List.map string_of_vdecl fdecl.slocals) ^
  String.concat "" (List.map string_of_sstmt fdecl.sbody) ^
let string_of_sprogram (vars, funcs) =
  String.concat "" (List.map string_of_vdecl vars) ^ "\n" ^
  String.concat "\n" (List.map string_of_sfdecl funcs)
	.asciz	"string_of"
      | BLIT(b) -> "BLIT(" ^ string_of_bool b ^ ")"
      | LITERAL(l) -> "LITERAL(" ^ string_of_int l ^ ")"
